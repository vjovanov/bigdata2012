\section{Background}
\label{sec:background}

% language virtualization
\subsection{Virtualized Scala}
\label{subsec:virtualized-scala}
\tool is built with an experimental version of Scala called Virtualized Scala \cite{sv}. Virtualized Scala provides facilities for simplified deep embedding of domain specific languages. Main facility for achieving this is the desugaring of regular language constructs like conditionals, loops, variable declarations, return statements and equality comparisons to simple method calls. For example, \code{if (c) a else b} gets translated to an \code{__ifThenElse(c, a, b)} method call. In the case of regular language execution this method executes the logic of the conditional but in case of deeply embedded DSLs it is used for creation of  IR node that represents the \code{if} statement.  

In Virtualized Scala, all embedded DSLs are written within DSL scopes. These special scopes look like method invocations that take one by name parameter. However, they get translated to the complete specification of DSL modules that are used in a form of a Scala trait mix-in composition\todo{put a star what is a mixin composition}. For example: 
\code{stivo\{ \\\\ dsl code \}} gets translated into:
\scode{new StivoDSL \{
 def main()\{
   \\\\ dsl code
 \}
\}} 
This makes all the DSL functionality defined in StivoDSL visible in body of the by name parameter passed to stivo method. 
Although modified, Virtualized Scala is fully binary compatible with Scala and can use all existing libraries.  

  
%??? infix-methods, if the type of expression x does not have method m but there is an infix method defined in the scope it will be desugared to infix_m(x) of the expression x m does not type check 

\subsection{Lightweight Modular Staging}
\label{subsec:lightweight-modular-staging}

% lms basics 
The base for the \tool project is LMS (Lightweight Modular Staging) library \todo{cite} which utilizes facilities provided by Virtualized Scala to build a modular infrastructure for developing staged DSLs. LMS library represents types in a DSLs with an abstract polymorphic data type \code{Rep[T]}. When in a DSL scope term has type \code{Rep[T]} it means that once the code is staged, optimized and generated the actual result of the term will have type \code{T}.  Since \code{Rep[T]} is and abstract type each DSL module can specify concrete operations on it which are used for simple building of the DSL intermediate representation. For example: 

% Here we represent a simple Exp example in several lines of code.
 
Since Scala's type system supports type inference \todo{which? It is not HM.} most of the Rep[T] types are hidden from the DSL user. This makes the DSL code almost completely free of type information and makes the user almost unaware of the Rep types. The only exception for visibility of Rep types are the parameters of defined methods and fields of defined classes.

% LMS effects
Although Scala does not provide effects tracking LMS framework provides it for basic building blocks like simple numerical expressions, conditionals and loops.  
% staging library
% uses language virtualization to construct an IR out from regular language constructs 
% types in the dsl are represented abstract data types and operations on them are    
% rep-types 


 
% modularity through scalable components abstraction.
% code generation is just another component so the existing components can be used. 