\section{Optimizations}
\label{sec:optimizations}
In this Section we present the main optimizations implemented in \tool.
\subsection{Projection Insertion}
\label{sec:field-reduction}
\newcommand{\aos}{AoS $\rightarrow$ SoA }

% Intro/Motivation 
A common optimization in data processing is to remove intermediate values early that are not needed in later phases of the computation. It has been implemented in relational databases for a long time, and has recently been added to the Pig framework. This optimization requires all field accesses in the program to be explicit. A library can provide this, but its usage is more intrusive than if the framework can use compiler support. 

% description of supported types
In \tool we support this optimization for algebraic data types, more specifically final immutable Scala classes with a finite level of nesting. Our approach does not require special syntax or access operators and supports method declarations on data types just like methods of regular Scala classes. While implementing our benchmarks we found this to be a reasonably expressive model for big data programming. The DSL user needs to supply class declarations, from which we generate all the necessary code for its use in \tool. In these cases, LMS describes all field accesses explicitly and we can generate highly specialized code for these types serialization schemes for the backends we support.

% Explain why our algorithm is so simple
A projection insertion optimization needs to know about the liveness of all fields it can possibly remove. LMS provides this within a scope, by decomposing all control structures to multiple copies of it accessing each field separately. After DCE, all remaining fields are alive within that scope. For \tool, this is not enough, as we support operations in the data-flow graph, like \code{groupByKey}, for which we found no good way to decompose them. However, we can define a liveness analysis for each operation in our programming model. For operations that accept a closure, we can apply \aos inside that closure. For all operations in our API we identify rules on how this operation influences the liveness of fields. By performing this analysis on each node in reverse topologically sorted order and propagating the liveness information to its predecessors, we can perform removal of unused fields. On a distributed program, the removal of dead fields is especially important before an operation that requires network transport of an object or stores it in memory. We call such an operation a barrier, and insert a projection which only contain the live fields before. An additional projection may introduce cpu overhead without offering a benefit in case there is no constructor invocation in the previous scope. In these cases we simply do not insert a projection.

%introduce paths
Since we support nested classes, the nested fields of a class form a tree, and if a field in such a tree is alive, it requires liveness of all its ancestors. We call the path of a nested field to the root of the tree an access path, and represent it using a string. The Figure \ref{fig:type_tree} shows the tree of nested fields of the class Tuple2[String, A], given in Listing \ref{lst:types}. The labels of the nodes describe the class of that field, while the edge labels contains the field name. The access path to each nested field can be formed by concatenating the edge labels with dots in between. In the Figure, the access path for the field id in class B would be \code{_2.b.id}. For each edge in the data-flow graph our operations form we need to compute the set of access paths.

\begin{figure}
% \begin{subfigure}
\begin{lstlisting}[language=Scala,name=code, caption=Nested type for paths example., captionpos=b, label=lst:types]
case class A(id: String, b: B)
case class B(id: String)  
val t = ("tuple", A("a", B("b"))) 
t: scala.Tuple2[String, A]
\end{lstlisting}
% \end{subfigure}
% \begin{subfigure}
\centering
\includegraphics[clip=true, width=0.95\columnwidth]{dot/access.png}
\caption{Visualization of the tree of fields for class Tuple2[String, A]}
\label{fig:type_tree}
% \end{subfigure}
\end{figure}

% explaining the analysis
For each operation, we need to define how the access paths used by it are translated into the access paths it uses. For this analysis we used following primitives:
\begin{itemize}
\item \emph{Access paths for type}: Given a type, this primitive creates access paths for all the nested fields within. In Listing \ref{lst:types} a \code{DList.save()} with elements of type A returns the access paths ${id, b, b.id}$. 
\item \emph{Closure analysis}: This primitive returns a list of all accses paths on an the closure's input type.
\item \emph{Rewrite access paths}: Several operations have defined semantics which influence the type and therefore the access paths. For example, the \code{cache} operation will always have the same input and output type and is known to not change any fields, so all access paths from its successors must be propagated to its predecessors. The \code{groupByKey} operation on the other hand always reads all nested fields of the key, and has to rewrite all access paths of the form \code{\_2.iterable.x} to \code{\_2.x}, as the \code{iterable} is introduced by the \code{groupByKey} operation and does not change the values.
\item \emph{Narrow closure}: Given a closure and the access paths its successors read from it, this primitive replaces the closure's original output with one that reads from it and creates a new output only containing the live fields.
\end{itemize}

\begin{table}[width=0.5\pagewidth, float=t]

    \begin{tabularx}{0.5\textwidth}{l|X|l}
        Operation    & Propagate access paths 							     & Barrier \\ \hline
        \code{filter}       & All access paths of successor + access paths of closure                                                      & ~       \\ 
        \code{flatMap}      & Return closure analysis of narrowed closure                                             & ~       \\ 
        \code{map}          & Return closure analysis of narrowed closure                                           & ~       \\ 
        \code{join}         & Generates access paths all nested fields of the key, and propagates access paths to the values to the correct predecessor.    & x       \\ 
        \code{groupByKey}   & Generates access paths all nested fields of the key, propagates the accesses to the value's iterable to the value itself  & x       \\ 
        \code{reduce}       & All accesses from the closure are translated to accesses of the value's iterable and propagated        & ~       \\ 
        \code{save}         & Generates all access paths for the input type           	                                             & ~       \\ 
    \end{tabularx}
    
    \caption{Access path computation and propagation for selected operations.}
    \label{table:field_reduction}
\end{table}

%make an example for map
To analyze a \code{map} operation, we need to combine the narrow closure and the closure analysis primitive. \aos ensures that the output symbol of a closure is always a constructor invocation, if the output type is not primitive. We apply the narrow closure primitive to create a new closure, in which the output symbol reads from the old output symbol. LMS recognizes when a field read reads from a constructor invocation in the same scope, and instead of generating an access for a field, it returns that value directly. This happens for all the fields, therefore the old constructor invocation will not be read anymore, and DCE will pick it up. This means that the field values, which only it was reading, will also not be read anymore, and they too will be eliminated. When the closure has been cleand up like this, we can analyze this new closure to get the access paths from it. 

Table \ref{table:field_reduction} shows further examples how these primitives are combined to form the rules for the most important operations in our API.
