\section{Introduction}
\label{sec:introduction}

% Motivation -- three different mixes of programming models and their problems
In the past decade numerous systems for BigData cluster computing have been studied \cite{dean_mapreduce:_2008, yu_dryadlinq:_2008-1, olston_pig_2008-1, thusoo_hive_2010-1, zaharia_spark:_2010}. Programming models of these systems impose a trade-off between generality, performance and productivity. Systems like Hadoop \cite{_hadoop_????} provide a low level general purpose programming model that allows writing of fine grained and optimized code.  However, low level optimizations greatly sacrifice productivity\todo{what nephele cited}. Limited programming models like SQL and Pig latin \cite{olston_pig_2008-1} exploit domain knowledge to provide both good performance and productivity for large number of use cases. However, their generality is supported through user defined functions that are cumbersome and often disable optimizations. Finally, models like Spark \cite{zaharia_spark:_2010}, FlumeJava \cite{chambers_flumejava:_2010} and Dryad/LINQ \cite{yu_dryadlinq:_2008-1} provide high level operations and general purpose programming models but their performance is limited by glue code and lack of knowledge about program structure. Moreover, the number of existing programming models great and they significantly differ. This leads to low code portability and makes migration to a new framework very hard. 
% Should we mix in the multiple frameworks here.

% Trade-off - why cant there be both generality, performance and productivity
This trade-off exists because in imperative and polymorphic programming models operations can have arbitrary side effects and the structure of the whole program (AST) is not available at runtime. This precludes the compiler to highly optimize the code and high level operations are glued together with inefficient abstractions like iterators and channels. Side effect free operations like date/time instantiation, regular expression compilation and high precision decimal numbers are often hidden by abstraction and recomputed in the hot path for each piece of data. Although domain specific approaches like Pig and SQL through their narrow, side effect free, interface provide good optimizations they come with their own set of limitations. Interface is often too narrow for the problem leading to either invoking host language operations which are disable optimization or to abandoning the model completely. Moreover, there is the overhead of learning the new language and embedding of the language into the host language which provides debugging, type driven correctness checking and IDE.     

% Existing Solutions to achieve this. 
In the recent history there have been several solutions that try to make programming data systems efficient, productive and general. Steno \cite{murray_steno:_2011}, implements an innovative runtime code generation scheme that aims to eliminate iterators in Dryad/LINQ queries. It operates over flat and nested queries and produces a minimal number of while loops without any iterator calls. Manimal \cite{cafarella_manimal:_2010} and HadoopToSQL \cite{iu_hadooptosql:_2010} apply byte code analysis to extract information about accessed fields and selection branches to gain enough knowledge to apply common relational database optimizations. Both solutions are safely conservative in their code analysis which can lead to missed optimization opportunities.         
% Steno with iterator fusion, uses intriging pushdown automata translation scheme to eliminate iterators used in glueing high level operations together in Dryad/LINQ. Although they achive 
% Manimal do byte code analisis to infer properties of mapper function, however they - methods? -percentage, field analysis over just one phase. columnar storage. Also, it does not provide high level programming model.  
% \todo{Side effect tracking in Hadoop.}

This paper presents a new domain specific language \tool for BigData processing that provides a high level interface similar to the Spark framework. Unlike Spark, \tool uses language virtualization \cite{moors_scala-virtualized_2012} and light weight modular staging (LMS)\cite{rompf_lightweight_2010} to get runtime access to the program structure. LMS enforces explicit effects tracking and provides DSL modules for basic language constructs and often used libraries giving \tool great generality. \tool uses exposed program structure with effects to apply optimizations like code motion, loop fusion and field elimination. Highly optimized intermediate representations is then used to generate code for Spark, Scoobi \cite{nicta_scoobi_2012} and Crunch \cite{_crunch_2012}. Due to LMS modularity \tool can be extended to arbitrary operations and written code is portable between frameworks by replacing thin code generation layer. 
 
% Evaluation TODO(Stivo, vjovanov)

% Contributions 
\tool makes following contributions to the state of the art:    
\begin{itemize}
  \item We demonstrate a high level and general programming model for BigData processing that does not come with the abstraction penalty and allows for SQL like domain specific optimizations.
  \item We introduce a novel field reduction mechanism that uses \todo{name and specify tiarks optimization} across \todo{scopes}. This makes is suitable for operates across general program constructs like conditionals, loops and methods.
  \item We show that language virtualization and modular staging approach permit framework specific optimizations and code portability for Big Data systems.
\end{itemize} 

% Sections
In section \ref{sec:background} we will provide background on LMS and language virtualization. In section \ref{sec:programming-model} we explain the interface and present simple program examples. Section \ref{sec:compiler} describes code motion, iterator fusion and other compiler optimizations. Section \ref{sec:field-reduction} explains the field reduction optimization. We evaluate \tool in \ref{sec:evaluation}, present related work in \ref{sec:related-work} and talk about future work and conclusions in \ref{sec:conclusion}.